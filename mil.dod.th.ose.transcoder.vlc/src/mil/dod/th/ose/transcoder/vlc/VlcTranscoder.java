//==============================================================================
// This software is part of the Open Standard for Unattended Sensors (OSUS)
// reference implementation (OSUS-R).
//
// To the extent possible under law, the author(s) have dedicated all copyright
// and related and neighboring rights to this software to the public domain
// worldwide. This software is distributed without any warranty.
//
// You should have received a copy of the CC0 Public Domain Dedication along
// with this software. If not, see
// <http://creativecommons.org/publicdomain/zero/1.0/>.
//==============================================================================
package mil.dod.th.ose.transcoder.vlc;

import java.net.URI;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import aQute.bnd.annotation.component.Activate;
import aQute.bnd.annotation.component.Component;
import aQute.bnd.annotation.component.Deactivate;
import aQute.bnd.annotation.component.Reference;
import mil.dod.th.core.log.LoggingService;
import mil.dod.th.core.transcoder.TranscoderException;
import mil.dod.th.core.transcoder.TranscoderService;
import uk.co.caprica.vlcj.player.headless.HeadlessMediaPlayer;


/**
 * This class uses the VLC media player to implement the {@link TranscoderService}. Specifically,
 * it uses the vlcj Java bindings for libVLC. See <a href="https://github.com/caprica/vlcj">
 * https://github.com/caprica/vlcj</a> for more information.
 * 
 * @author jmiller
 *
 */
@Component
public class VlcTranscoder implements TranscoderService
{
    /** Map structure to keep track of multiple media player instances. */
    private Map<String, HeadlessMediaPlayer> m_ProcessMap;
    
    /** Logging service instance. */
    private LoggingService m_LoggingService;
    
    static
    {
        NativeLibraryLoader.load();
    }
        
    /**
     * Bind the logging service.
     * @param logging
     *      service to bind.
     */
    @Reference
    public void setLoggingService(final LoggingService logging)
    {
        m_LoggingService = logging;
    }

    /**
     * Method called when component is activated.
     * 
     */
    @Activate
    public void activate()
    {
        m_ProcessMap = new HashMap<>();
    }


    /**
     * Method called when component is deactivated. Stop all existing processes.
     * 
     */
    @Deactivate
    public void deactivate()
    {
        for (HeadlessMediaPlayer player:m_ProcessMap.values())
        {
            player.stop();
            player.release();
        }

        m_ProcessMap = null;

    }

    @Override
    public void start(final String processId, final URI sourceUri, final URI outputUri, 
            final Map<String, Object> configParams) throws IllegalStateException, TranscoderException
    {

        if (m_ProcessMap.containsKey(processId))
        {
            throw new IllegalStateException("Transcoding process for ID: " + processId + " is already running");
        }

        final HeadlessMediaPlayer player = VlcUtils.newPlayer();
        
        player.addMediaPlayerEventListener(new VlcEventListener(this, processId));

        final String configString = VlcUtils.createConfigString(outputUri, configParams);
        final String mrl = sourceUri.toString();
        
        if (player.playMedia(mrl, new String[]{configString, ":network-caching=100", ":sout-keep"}))
        {
            //If media item is created successfully, keep track in process map
            m_ProcessMap.put(processId, player);
        }
        else
        {
            throw new TranscoderException("Error creating transcoding process with processId: " + processId);
        }

    }

    @Override
    public void stop(final String processId) throws IllegalArgumentException
    {
        final HeadlessMediaPlayer player = m_ProcessMap.get(processId);
        if (player == null)
        {
            throw new IllegalArgumentException("No transcoding process exists for ID: " + processId);
        }

        player.stop();
        player.release();
        m_ProcessMap.remove(processId);

    }

    /**
     * Get the String identifiers corresponding to active transcoding processes.
     * 
     * @return Set of String identifiers. Client/bundle can use each String value as an
     *      input for {@link #stop(String)}.
     */
    public Set<String> getActiveProcessIds()
    {
        return m_ProcessMap.keySet();
    }

    /**
     * Method to handle {@link uk.co.caprica.vlcj.player.MediaPlayerEventListener#playing(
     * uk.co.caprica.vlcj.player.MediaPlayer)} events generated by {@link HeadlessMediaPlayer}
     * instances.
     * 
     * @param eventListenerId
     *      String identifier assigned to the event listener
     */
    public void playingEvent(final String eventListenerId)
    {
        m_LoggingService.info("Received playing event for event listener ID: %s", eventListenerId);
    }

    /**
     * Method to handle {@link uk.co.caprica.vlcj.player.MediaPlayerEventListener#error(
     * uk.co.caprica.vlcj.player.MediaPlayer)} events generated by {@link HeadlessMediaPlayer}
     * instances.
     * 
     * @param eventListenerId
     *      String identifier assigned to the event listener
     */
    public void errorEvent(final String eventListenerId)
    {
        m_LoggingService.error("Received error event for event listener ID: %s", eventListenerId);
        if (m_ProcessMap.containsKey(eventListenerId))
        {
            m_ProcessMap.remove(eventListenerId);
        }
    }

    /**
     * Method to handle {@link uk.co.caprica.vlcj.player.MediaPlayerEventListener#stopped(
     * uk.co.caprica.vlcj.player.MediaPlayer)} events generated by {@link HeadlessMediaPlayer}
     * instances.
     * 
     * @param eventListenerId
     *      String identifier assigned to the event listener
     */
    public void stoppedEvent(final String eventListenerId)
    {
        m_LoggingService.info("Received stopped event for event listener ID: %s", eventListenerId);
    }

}
